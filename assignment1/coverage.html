
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>entity: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">assignment1/entity/submission.go (0.0%)</option>
				
				<option value="file1">assignment1/handler/submission_handler.go (0.0%)</option>
				
				<option value="file2">assignment1/handler/user_handler.go (24.0%)</option>
				
				<option value="file3">assignment1/main.go (0.0%)</option>
				
				<option value="file4">assignment1/middleware/auth.go (0.0%)</option>
				
				<option value="file5">assignment1/repository/postgres_gorm/submission.go (0.0%)</option>
				
				<option value="file6">assignment1/repository/postgres_gorm/user.go (9.6%)</option>
				
				<option value="file7">assignment1/router/router.go (0.0%)</option>
				
				<option value="file8">assignment1/service/submission_service.go (0.0%)</option>
				
				<option value="file9">assignment1/service/user_service.go (20.0%)</option>
				
				<option value="file10">assignment1/test/mock/handler/submission_handler_mock.go (0.0%)</option>
				
				<option value="file11">assignment1/test/mock/handler/user_handler_mock.go (0.0%)</option>
				
				<option value="file12">assignment1/test/mock/service/user_service_mock.go (30.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package entity

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"
)

// Submission struct representing the submission table
type Submission struct {
        ID           uint      `gorm:"primaryKey"`
        UserID       uint      `gorm:"not null"`
        User         *User     `gorm:"foreignKey:UserID;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;" json:"user,omitempty"`
        Answer       []byte    `gorm:"type:json"`
        RiskScore    int       `gorm:"not null"`
        RiskCategory string    `gorm:"size:255"`
        CreatedAt    time.Time `gorm:"autoCreateTime"`
        UpdatedAt    time.Time `gorm:"autoUpdateTime"`
}

// JSON custom type to handle JSON data
// type JSON map[string]interface{}
type JSON []byte

type Answer struct {
        QuestionID int    `json:"question_id"`
        Answer     string `json:"answer"`
}

// Scan implements the sql.Scanner interface for JSON
func (j *JSON) Scan(value interface{}) error <span class="cov0" title="0">{
        bytes, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(bytes, &amp;j)</span>
}

// Value implements the driver.Valuer interface for JSON
func (j JSON) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(j)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "assignment1/config"
        "assignment1/entity"
        "assignment1/service"
        "encoding/json"
        "log"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// Define your response struct
type GetSubmissionsResponse struct {
        Total       int64            `json:"total"`
        Page        int              `json:"page"`
        Limit       int              `json:"limit"`
        Submissions []SubmissionData `json:"submissions"`
}

type SubmissionData struct {
        ID             uint            `json:"id"`
        UserID         uint            `json:"user_id"`
        RiskScore      int             `json:"risk_score"`
        RiskCategory   string          `json:"risk_category"`
        RiskDefinition string          `json:"risk_definition"`
        Answers        []entity.Answer `json:"answers"`
        CreatedAt      string          `json:"created_at"`
        UpdatedAt      string          `json:"updated_at"`
}

// mendefinisikan interface untuk handler submission
type ISubmissionHandler interface {
        CreateSubmission(c *gin.Context)
        GetSubmission(c *gin.Context)
        DeleteSubmission(c *gin.Context)
        GetAllSubmissions(c *gin.Context)
        GetAllSubmissionsWithUser(c *gin.Context)
}

type SubmissionHandler struct {
        submissionService service.ISubmissionService
}

// NewUserHandler membuat instance baru dari UserHandler
func NewSubmissionHandler(submissionService service.ISubmissionService) ISubmissionHandler <span class="cov0" title="0">{
        return &amp;SubmissionHandler{
                submissionService: submissionService,
        }
}</span>

type CreateSubmissionRequest struct {
        UserID  uint            `json:"user_id"`
        Answers []entity.Answer `json:"answers"`
}

// menghandle permintaan untuk membuat submission baru
func (h *SubmissionHandler) CreateSubmission(c *gin.Context) <span class="cov0" title="0">{
        //defind request
        var submissionRequest CreateSubmissionRequest

        // Bind JSON dari body request ke struct submissionRequest
        if err := c.ShouldBindJSON(&amp;submissionRequest); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Convert answers to JSON type
        <span class="cov0" title="0">answersJSON, err := json.Marshal(submissionRequest.Answers)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process answers"})
                return
        }</span>

        <span class="cov0" title="0">totalWeight := calculateRiskScore(submissionRequest.Answers)
        // Simpan submission ke dalam database menggunakan GORM
        submission := entity.Submission{
                UserID:       submissionRequest.UserID,
                Answer:       answersJSON,
                RiskScore:    totalWeight,
                RiskCategory: calculateRiskCategory(totalWeight),
        }

        createdSubmission, err := h.submissionService.CreateSubmission(c.Request.Context(), &amp;submission)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Format the response message
        <span class="cov0" title="0">responseMessage := gin.H{
                "message": "Submission ID " + strconv.Itoa(int(createdSubmission.ID)) + " created successfully",
        }

        c.JSON(http.StatusCreated, responseMessage)</span>
}

// menghandle permintaan untuk mendapatkan submission berdasarkan ID
func (h *SubmissionHandler) GetSubmission(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">submission, err := h.submissionService.GetSubmissionByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Submission not found"})
                return
        }</span>

        // Unmarshal the answers from the submission
        <span class="cov0" title="0">var answers []entity.Answer
        err = json.Unmarshal(submission.Answer, &amp;answers)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error unmarshalling answers: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process answers"})
                return
        }</span>

        // Create the response struct
        <span class="cov0" title="0">response := SubmissionData{
                ID:             submission.ID,
                UserID:         submission.UserID,
                RiskScore:      submission.RiskScore,
                RiskCategory:   submission.RiskCategory,
                RiskDefinition: getRiskDefinition(config.ProfileRiskCategory(submission.RiskCategory)),
                Answers:        answers,
                CreatedAt:      submission.CreatedAt.Format("2006-01-02T15:04:05Z"),
                UpdatedAt:      submission.CreatedAt.Format("2006-01-02T15:04:05Z"),
        }

        c.JSON(http.StatusOK, response)</span>
}

// menghandle permintaan untuk menghapus user
func (h *SubmissionHandler) DeleteSubmission(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.submissionService.DeleteSubmission(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Submission deleted successfully"})</span>
}

// GetAllUsers menghandle permintaan untuk mendapatkan semua user
func (h *SubmissionHandler) GetAllSubmissions(c *gin.Context) <span class="cov0" title="0">{
        // Default values for page and pageSize
        const defaultPage = 1
        const defaultPageSize = 10

        page, err := strconv.Atoi(c.DefaultQuery("page", strconv.Itoa(defaultPage)))
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = defaultPage
        }</span>

        <span class="cov0" title="0">pageSize, err := strconv.Atoi(c.DefaultQuery("limit", strconv.Itoa(defaultPageSize)))
        if err != nil || pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = defaultPageSize
        }</span>

        // Get user_id from query parameters
        <span class="cov0" title="0">var userID *uint
        if userIDStr := c.Query("user_id"); userIDStr != "" </span><span class="cov0" title="0">{
                uid, err := strconv.Atoi(userIDStr)
                if err == nil </span><span class="cov0" title="0">{
                        uidUint := uint(uid)
                        userID = &amp;uidUint
                }</span>
        }

        // ctx := context.Background()

        <span class="cov0" title="0">submissions, total, err := h.submissionService.GetAllSubmissions(c.Request.Context(), page, pageSize, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var submissionData []SubmissionData
        for _, sub := range submissions </span><span class="cov0" title="0">{
                var answers []entity.Answer
                err := json.Unmarshal(sub.Answer, &amp;answers)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error unmarshalling answers: %v\n", err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process answers"})
                        return
                }</span>
                <span class="cov0" title="0">submissionData = append(submissionData, SubmissionData{
                        ID:             sub.ID,
                        UserID:         sub.UserID,
                        RiskScore:      sub.RiskScore,
                        RiskCategory:   sub.RiskCategory,
                        RiskDefinition: getRiskDefinition(config.ProfileRiskCategory(sub.RiskCategory)),
                        Answers:        answers,
                        CreatedAt:      sub.CreatedAt.Format("2006-01-02T15:04:05Z"),
                        UpdatedAt:      sub.UpdatedAt.Format("2006-01-02T15:04:05Z"),
                })</span>
        }

        <span class="cov0" title="0">response := GetSubmissionsResponse{
                Total:       total,
                Page:        page,
                Limit:       pageSize,
                Submissions: submissionData,
        }

        c.JSON(http.StatusOK, response)</span>
}

func (h *SubmissionHandler) GetAllSubmissionsWithUser(c *gin.Context) <span class="cov0" title="0">{
        // Default values for page and pageSize
        const defaultPage = 1
        const defaultPageSize = 10

        page, err := strconv.Atoi(c.DefaultQuery("page", strconv.Itoa(defaultPage)))
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = defaultPage
        }</span>

        <span class="cov0" title="0">pageSize, err := strconv.Atoi(c.DefaultQuery("limit", strconv.Itoa(defaultPageSize)))
        if err != nil || pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = defaultPageSize
        }</span>

        // Get user_id from query parameters
        <span class="cov0" title="0">var userID *uint
        if userIDStr := c.Query("user_id"); userIDStr != "" </span><span class="cov0" title="0">{
                uid, err := strconv.Atoi(userIDStr)
                if err == nil </span><span class="cov0" title="0">{
                        uidUint := uint(uid)
                        userID = &amp;uidUint
                }</span>
        }

        // ctx := context.Background()

        <span class="cov0" title="0">submissions, total, err := h.submissionService.GetAllSubmissionsWithUser(c.Request.Context(), page, pageSize, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var submissionData []SubmissionData
        for _, sub := range submissions </span><span class="cov0" title="0">{
                var answers []entity.Answer
                err := json.Unmarshal(sub.Answer, &amp;answers)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error unmarshalling answers: %v\n", err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process answers"})
                        return
                }</span>
                <span class="cov0" title="0">submissionData = append(submissionData, SubmissionData{
                        ID:             sub.ID,
                        UserID:         sub.UserID,
                        RiskScore:      sub.RiskScore,
                        RiskCategory:   sub.RiskCategory,
                        RiskDefinition: getRiskDefinition(config.ProfileRiskCategory(sub.RiskCategory)),
                        Answers:        answers,
                        CreatedAt:      sub.CreatedAt.Format("2006-01-02T15:04:05Z"),
                        UpdatedAt:      sub.UpdatedAt.Format("2006-01-02T15:04:05Z"),
                })</span>
        }

        <span class="cov0" title="0">response := GetSubmissionsResponse{
                Total:       total,
                Page:        page,
                Limit:       pageSize,
                Submissions: submissionData,
        }

        c.JSON(http.StatusOK, response)</span>
}

// Fungsi untuk mendapatkan bobot jawaban berdasarkan question_id dan answer
func calculateRiskScore(answers []entity.Answer) int <span class="cov0" title="0">{
        totalScore := 0
        for _, answer := range answers </span><span class="cov0" title="0">{
                for _, question := range config.Questions </span><span class="cov0" title="0">{ //ID QUESION
                        if question.ID == answer.QuestionID </span><span class="cov0" title="0">{
                                for _, option := range question.Options </span><span class="cov0" title="0">{
                                        if option.Answer == answer.Answer </span><span class="cov0" title="0">{
                                                totalScore += option.Weight
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">break</span>
                        }
                }
        }
        <span class="cov0" title="0">return totalScore</span>
}

func calculateRiskCategory(totalWeight int) string <span class="cov0" title="0">{
        for _, risk := range config.RiskMapping </span><span class="cov0" title="0">{
                if totalWeight &gt;= risk.MinScore &amp;&amp; totalWeight &lt;= risk.MaxScore </span><span class="cov0" title="0">{
                        return string(risk.Category)
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func getRiskDefinition(category config.ProfileRiskCategory) string <span class="cov0" title="0">{
        for _, profileRisk := range config.RiskMapping </span><span class="cov0" title="0">{
                if profileRisk.Category == category </span><span class="cov0" title="0">{
                        return profileRisk.Definition
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "log"
        "net/http"
        "strconv"
        "strings"
        "time"

        "assignment1/config"
        "assignment1/entity"
        "assignment1/service"

        "github.com/gin-gonic/gin"
)

type UserWithRiskResponse struct {
        ID             uint   `json:"id"`
        Name           string `json:"name"`
        Email          string `json:"email"`
        RiskScore      int    `json:"risk_score"`
        RiskCategory   string `json:"risk_category"`
        RiskDefinition string `json:"risk_definition"`
        CreatedAt      string `json:"created_at"`
        UpdatedAt      string `json:"updated_at"`
}

// IUserHandler mendefinisikan interface untuk handler user
type IUserHandler interface {
        CreateUser(c *gin.Context)
        GetUser(c *gin.Context)
        UpdateUser(c *gin.Context)
        DeleteUser(c *gin.Context)
        GetAllUsers(c *gin.Context)
        GetAllUsersWithRIsk(c *gin.Context)
}

type UserHandler struct {
        userService service.IUserService
}

// NewUserHandler membuat instance baru dari UserHandler
func NewUserHandler(userService service.IUserService) IUserHandler <span class="cov8" title="1">{
        return &amp;UserHandler{
                userService: userService,
        }
}</span>

// UserResponse defines the structure of user response
type UserResponse struct {
        ID        uint   `json:"id"`
        Name      string `json:"name"`
        Email     string `json:"email"`
        CreatedAt string `json:"created_at"`
        UpdatedAt string `json:"updated_at"`
}

// CreateUser menghandle permintaan untuk membuat user baru
func (h *UserHandler) CreateUser(c *gin.Context) <span class="cov8" title="1">{
        var user entity.User
        if err := c.ShouldBindJSON(&amp;user); err != nil </span><span class="cov8" title="1">{
                errMsg := err.Error()
                errMsg = convertUserMandatoryFieldErrorString(errMsg)
                c.JSON(http.StatusBadRequest, gin.H{"error": errMsg})
                return
        }</span>

        <span class="cov8" title="1">createdUser, err := h.userService.CreateUser(c.Request.Context(), &amp;user)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Format the response message
        <span class="cov8" title="1">responseMessage := gin.H{
                "message": "User ID " + strconv.Itoa(int(createdUser.ID)) + " created successfully",
        }

        c.JSON(http.StatusCreated, responseMessage)</span>
}

// GetUser menghandle permintaan untuk mendapatkan user berdasarkan ID
func (h *UserHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov0" title="0">var responseUser []UserWithRiskResponse
        var riskScore int
        var riskCategory string
        var riskDefinition string

        if len(user.Submissions) &gt; 0 </span><span class="cov0" title="0">{
                riskScore = user.Submissions[0].RiskScore
                riskCategory = user.Submissions[0].RiskCategory
                riskDefinition = getRiskDefinition(config.ProfileRiskCategory(user.Submissions[0].RiskCategory))
        }</span>

        <span class="cov0" title="0">responseUser = append(responseUser, UserWithRiskResponse{
                ID:             user.ID,
                Name:           user.Name,
                Email:          user.Email,
                RiskScore:      riskScore,
                RiskCategory:   riskCategory,
                RiskDefinition: riskDefinition,
                CreatedAt:      user.CreatedAt.Format("2006-01-02T15:04:05Z"),
                UpdatedAt:      user.UpdatedAt.Format("2006-01-02T15:04:05Z"),
        })

        c.JSON(http.StatusOK, responseUser[0])</span>
}

// UpdateUser menghandle permintaan untuk mengupdate informasi user
func (h *UserHandler) UpdateUser(c *gin.Context) <span class="cov8" title="1">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov8" title="1">var user entity.User
        if err := c.ShouldBindJSON(&amp;user); err != nil </span><span class="cov0" title="0">{
                errMsg := err.Error()
                errMsg = convertUserMandatoryFieldErrorString(errMsg)
                c.JSON(http.StatusBadRequest, gin.H{"error": errMsg})
                return
        }</span>

        <span class="cov8" title="1">updatedUser, err := h.userService.UpdateUser(c.Request.Context(), id, user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        // Format the response message
        <span class="cov8" title="1">responseMessage := gin.H{
                "message": "User ID " + strconv.Itoa(int(updatedUser.ID)) + " updated successfully",
        }

        c.JSON(http.StatusOK, responseMessage)</span>
}

// DeleteUser menghandle permintaan untuk menghapus user
func (h *UserHandler) DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.userService.DeleteUser(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})</span>
}

// GetAllUsers menghandle permintaan untuk mendapatkan semua user
func (h *UserHandler) GetAllUsers(c *gin.Context) <span class="cov0" title="0">{
        // Default values for page and pageSize
        const defaultPage = 1
        const defaultPageSize = 10

        page, err := strconv.Atoi(c.DefaultQuery("page", strconv.Itoa(defaultPage)))
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = defaultPage
        }</span>

        <span class="cov0" title="0">pageSize, err := strconv.Atoi(c.DefaultQuery("limit", strconv.Itoa(defaultPageSize)))
        if err != nil || pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = defaultPageSize
        }</span>

        // ctx := context.Background()
        <span class="cov0" title="0">users, total, err := h.userService.GetAllUsers(c.Request.Context(), page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // users, total, err := h.userService.GetAllUsers(c.Request.Context(), page, pageSize)
        // if err != nil {
        //         c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        //         return
        // }

        // Transform users to UserResponse
        <span class="cov0" title="0">var userResponses []UserResponse
        for _, user := range users </span><span class="cov0" title="0">{
                log.Println(user)
                userResponse := UserResponse{
                        ID:        user.ID,
                        Name:      user.Name,
                        Email:     user.Email,
                        CreatedAt: user.CreatedAt.Format(time.RFC3339),
                        UpdatedAt: user.UpdatedAt.Format(time.RFC3339),
                }
                userResponses = append(userResponses, userResponse)
        }</span>

        // Calculate total pages
        <span class="cov0" title="0">totalPages := (total + int64(pageSize) - 1) / int64(pageSize)

        c.JSON(http.StatusOK, gin.H{"users": userResponses, "total_pages": totalPages, "current_page": page, "total_data": total, "total_perpage": pageSize})</span>
}

func (h *UserHandler) GetAllUsersWithRIsk(c *gin.Context) <span class="cov0" title="0">{
        page, err := strconv.Atoi(c.DefaultQuery("page", "1"))
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">pageSize, err := strconv.Atoi(c.DefaultQuery("limit", "10"))
        if err != nil || pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>

        <span class="cov0" title="0">users, total, err := h.userService.GetAllUsersWithRisk(c.Request.Context(), page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get users"})
                return
        }</span>

        <span class="cov0" title="0">var responseUser []UserWithRiskResponse
        for _, sub := range users </span><span class="cov0" title="0">{
                var riskScore int
                var riskCategory string
                var riskDefinition string

                if len(sub.Submissions) &gt; 0 </span><span class="cov0" title="0">{
                        riskScore = sub.Submissions[0].RiskScore
                        riskCategory = sub.Submissions[0].RiskCategory
                        riskDefinition = getRiskDefinition(config.ProfileRiskCategory(sub.Submissions[0].RiskCategory))
                }</span>

                <span class="cov0" title="0">responseUser = append(responseUser, UserWithRiskResponse{
                        ID:             sub.ID,
                        Name:           sub.Name,
                        Email:          sub.Email,
                        RiskScore:      riskScore,
                        RiskCategory:   riskCategory,
                        RiskDefinition: riskDefinition,
                        CreatedAt:      sub.CreatedAt.Format("2006-01-02T15:04:05Z"),
                        UpdatedAt:      sub.UpdatedAt.Format("2006-01-02T15:04:05Z"),
                })</span>
        }

        <span class="cov0" title="0">response := gin.H{
                "users":        responseUser,
                "total_pages":  (total + int64(pageSize) - 1) / int64(pageSize),
                "current_page": page,
        }

        c.JSON(http.StatusOK, response)</span>
}

func convertUserMandatoryFieldErrorString(oldErrorMsg string) string <span class="cov8" title="1">{
        switch </span>{
        case strings.Contains(oldErrorMsg, "'Name' failed on the 'required' tag"):<span class="cov8" title="1">
                return "name is mandatory"</span>
        case strings.Contains(oldErrorMsg, "'Email' failed on the 'required' tag"):<span class="cov8" title="1">
                return "email is mandatory"</span>
        }
        <span class="cov0" title="0">return oldErrorMsg</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "assignment1/entity"
        "assignment1/repository/postgres_gorm"
        "assignment1/router"
        "fmt"
        "log"

        "assignment1/handler"
        "assignment1/service"

        "github.com/gin-gonic/gin"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func main() <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        r := gin.Default()

        //Koneksion db using gorm
        dsn := "postgresql://postgres:postgres@localhost:5432/db_training_golang_assignment1"
        gormDB, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{SkipDefaultTransaction: true})
        if err != nil </span><span class="cov0" title="0">{
                log.Println(gormDB)
                log.Fatalln(err)
        }</span>

        // Migrate the schema
        <span class="cov0" title="0">err = gormDB.AutoMigrate(entity.User{}, entity.Submission{})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to migrate database schema:", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Database schema migrated successfully")
        }</span>

        // uncomment to use postgres gorm
        <span class="cov0" title="0">userRepo := postgres_gorm.NewUserRepository(gormDB)

        // service and handler declaration
        userService := service.NewUserService(userRepo)
        userHandler := handler.NewUserHandler(userService)

        // uncomment to use postgres gorm
        submissionRepo := postgres_gorm.NewSubmissionRepository(gormDB)

        // service and handler declaration
        submissionService := service.NewSubmissionService(submissionRepo)
        submissionHandler := handler.NewSubmissionHandler(submissionService)

        // Routes
        router.SetupRouter(r, userHandler, submissionHandler)

        // Run the server
        log.Println("Running server on port 8080")
        r.Run(":8080")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "assignment1/config"
        "net/http"

        "github.com/gin-gonic/gin"
)

func AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Verifikasi token (misalnya, cocokkan dengan token yang diharapkan)
                username, password, ok := c.Request.BasicAuth()
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization basic token required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">isValid := (username == config.AuthBasicUsername) &amp;&amp; (password == config.AuthBasicPassword)
                if !isValid </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization token"})
                        c.Abort()
                        return
                }</span>

                // Lanjutkan ke handler berikutnya jika token valid
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package postgres_gorm

import (
        "assignment1/entity"
        "assignment1/service"
        "context"
        "errors"
        "log"

        "gorm.io/gorm"
)

type submissionRepository struct {
        db GormDBIface
}

// NewUserRepository membuat instance baru dari userRepository
func NewSubmissionRepository(db GormDBIface) service.ISubmissionRepository <span class="cov0" title="0">{
        return &amp;submissionRepository{db: db}
}</span>

// Create submission
func (r *submissionRepository) CreateSubmission(ctx context.Context, submission *entity.Submission) (entity.Submission, error) <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Create(submission).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating submission: %v\n", err)
                return entity.Submission{}, err
        }</span>
        <span class="cov0" title="0">return *submission, nil</span>
}

// GetUserByID mengambil pengguna berdasarkan ID
func (r *submissionRepository) GetSubmissionByID(ctx context.Context, id int) (entity.Submission, error) <span class="cov0" title="0">{
        var submission entity.Submission
        if err := r.db.WithContext(ctx).First(&amp;submission, id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return entity.Submission{}, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Error getting submission by ID: %v\n", err)
                return entity.Submission{}, err</span>
        }
        <span class="cov0" title="0">return submission, nil</span>
}

// Deletesubmission menghapus pengguna berdasarkan ID
func (r *submissionRepository) DeleteSubmission(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Delete(&amp;entity.Submission{}, id).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error deleting submission: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAll Submission
func (r *submissionRepository) GetAllSubmissions(ctx context.Context, page int, pageSize int, userID *uint) ([]entity.Submission, int64, error) <span class="cov0" title="0">{
        var submissions []entity.Submission
        var total int64

        offset := (page - 1) * pageSize

        query := r.db.WithContext(ctx).Model(&amp;entity.Submission{})
        if userID != nil </span><span class="cov0" title="0">{
                query = query.Where("user_id = ?", *userID)
        }</span>

        //query count data
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if err := query.Limit(pageSize).Offset(offset).Find(&amp;submissions).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return submissions, total, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Error getting all submissions: %v\n", err)
                return nil, 0, err</span>
        }

        <span class="cov0" title="0">return submissions, total, nil</span>
}

func (r *submissionRepository) GetAllSubmissionsWithUser(ctx context.Context, page int, pageSize int, userID *uint) ([]entity.Submission, int64, error) <span class="cov0" title="0">{
        var submissions []entity.Submission
        var total int64

        offset := (page - 1) * pageSize

        query := r.db.WithContext(ctx).Model(&amp;entity.Submission{})
        if userID != nil </span><span class="cov0" title="0">{
                query = query.Where("user_id = ?", *userID)
        }</span>

        //query count data
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if err := query.Preload("User").Limit(pageSize).Order("created_at DESC").Offset(offset).Find(&amp;submissions).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return submissions, total, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Error getting all submissions: %v\n", err)
                return nil, 0, err</span>
        }

        <span class="cov0" title="0">return submissions, total, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package postgres_gorm

import (
        "assignment1/entity"
        "assignment1/service"
        "context"
        "errors"
        "log"

        "gorm.io/gorm"
)

// GormDBIface defines an interface for GORM DB methods used in the repository
type GormDBIface interface {
        WithContext(ctx context.Context) *gorm.DB
        Create(value interface{}) *gorm.DB
        First(dest interface{}, conds ...interface{}) *gorm.DB
        Save(value interface{}) *gorm.DB
        Delete(value interface{}, conds ...interface{}) *gorm.DB
        Find(dest interface{}, conds ...interface{}) *gorm.DB
        Count(count *int64) *gorm.DB
        Table(string, ...interface{}) *gorm.DB
}

type userRepository struct {
        db GormDBIface
}

// NewUserRepository membuat instance baru dari userRepository
func NewUserRepository(db GormDBIface) service.IUserRepository <span class="cov8" title="1">{
        return &amp;userRepository{db: db}
}</span>

// CreateUser membuat pengguna baru dalam basis data
func (r *userRepository) CreateUser(ctx context.Context, user *entity.User) (entity.User, error) <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Create(user).Error; err != nil </span><span class="cov8" title="1">{
                log.Printf("Error creating user: %v\n", err)
                return entity.User{}, err
        }</span>
        <span class="cov8" title="1">return *user, nil</span>
}

// GetUserByID mengambil pengguna berdasarkan ID
func (r *userRepository) GetUserByID(ctx context.Context, id int) (entity.User, error) <span class="cov0" title="0">{
        var user entity.User
        if err := r.db.WithContext(ctx).Preload("Submissions", func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                return db.Order("created_at desc").Limit(1)
        }</span>).First(&amp;user, id).Error; err != nil <span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return entity.User{}, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Error getting user by ID: %v\n", err)
                return entity.User{}, err</span>
        }
        <span class="cov0" title="0">return user, nil</span>
}

// UpdateUser memperbarui informasi pengguna dalam basis data
func (r *userRepository) UpdateUser(ctx context.Context, id int, user entity.User) (entity.User, error) <span class="cov0" title="0">{
        // Menemukan pengguna yang akan diperbarui
        var existingUser entity.User
        if err := r.db.WithContext(ctx).Select("id", "name", "email", "created_at", "updated_at").First(&amp;existingUser, id).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error finding user to update: %v\n", err)
                return entity.User{}, err
        }</span>

        // Memperbarui informasi pengguna
        <span class="cov0" title="0">existingUser.Name = user.Name
        existingUser.Email = user.Email
        if err := r.db.WithContext(ctx).Save(&amp;existingUser).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error updating user: %v\n", err)
                return entity.User{}, err
        }</span>
        <span class="cov0" title="0">return existingUser, nil</span>
}

// DeleteUser menghapus pengguna berdasarkan ID
func (r *userRepository) DeleteUser(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Delete(&amp;entity.User{}, id).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error deleting user: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAllUsers mengambil semua pengguna dari basis data
func (r *userRepository) GetAllUsers(ctx context.Context, page int, pageSize int) ([]entity.User, int64, error) <span class="cov0" title="0">{
        var users []entity.User
        var total int64

        offset := (page - 1) * pageSize

        //count data
        if err := r.db.WithContext(ctx).Model(&amp;entity.User{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error counting users: %v\n", err)
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := r.db.WithContext(ctx).Select("id", "name", "email", "created_at", "updated_at").Limit(pageSize).Offset(offset).Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return users, total, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Error getting all users: %v\n", err)
                return nil, 0, err</span>
        }
        <span class="cov0" title="0">return users, total, nil</span>
}

func (r *userRepository) GetAllUsersWithRisk(ctx context.Context, page int, pageSize int) ([]entity.User, int64, error) <span class="cov0" title="0">{
        var users []entity.User
        var total int64

        offset := (page - 1) * pageSize

        //count data
        if err := r.db.WithContext(ctx).Model(&amp;entity.User{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error counting users: %v\n", err)
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := r.db.WithContext(ctx).Preload("Submissions", func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                return db.Order("created_at desc").Limit(1)
        }</span>).Limit(pageSize).Offset(offset).Find(&amp;users).Error; err != nil <span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return users, total, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Error getting all users: %v\n", err)
                return nil, 0, err</span>
        }
        <span class="cov0" title="0">return users, total, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package router

import (
        "assignment1/handler"
        "assignment1/middleware"

        "github.com/gin-gonic/gin"
)

func SetupRouter(r *gin.Engine, userHandler handler.IUserHandler, submissionHandler handler.ISubmissionHandler) <span class="cov0" title="0">{
        //endpoint users group
        //mengutur endpoint public
        usersPublicEndpoint := r.Group("/users")
        usersPublicEndpoint.GET("/:id", userHandler.GetUser)
        usersPublicEndpoint.GET("/", userHandler.GetAllUsersWithRIsk)

        // Mengatur endpoint privat untuk pengguna dengan middleware autentikasi
        usersPrivateEndpoint := r.Group("/users")
        usersPrivateEndpoint.Use(middleware.AuthMiddleware())
        usersPrivateEndpoint.POST("", userHandler.CreateUser)
        usersPrivateEndpoint.POST("/", userHandler.CreateUser)
        usersPrivateEndpoint.PUT("/:id", userHandler.UpdateUser)
        usersPrivateEndpoint.DELETE("/:id", userHandler.DeleteUser)

        //endpoint submisson group
        submissionPublicEndpoint := r.Group("/submissions")
        submissionPublicEndpoint.GET("/:id", submissionHandler.GetSubmission)
        submissionPublicEndpoint.GET("/", submissionHandler.GetAllSubmissions)

        submissionPrivateEndpoint := r.Group("/submissions")
        submissionPrivateEndpoint.Use(middleware.AuthMiddleware())
        submissionPrivateEndpoint.POST("", submissionHandler.CreateSubmission)
        submissionPrivateEndpoint.POST("/", submissionHandler.CreateSubmission)
        submissionPrivateEndpoint.DELETE("/:id", submissionHandler.DeleteSubmission)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package service

import (
        "assignment1/entity"
        "context"
        "fmt"
)

// ISubmissionService mendefinisikan interface untuk layanan pengguna
type ISubmissionService interface {
        CreateSubmission(ctx context.Context, submission *entity.Submission) (entity.Submission, error)
        GetSubmissionByID(ctx context.Context, id int) (entity.Submission, error)
        DeleteSubmission(ctx context.Context, id int) error
        GetAllSubmissions(ctx context.Context, page int, pageSize int, userID *uint) ([]entity.Submission, int64, error)         // Menambahkan parameter page dan pageSize
        GetAllSubmissionsWithUser(ctx context.Context, page int, pageSize int, userID *uint) ([]entity.Submission, int64, error) // Menambahkan parameter page dan pageSize
}

// ISubmissionRepository mendefinisikan interface untuk repository pengguna
type ISubmissionRepository interface {
        CreateSubmission(ctx context.Context, submission *entity.Submission) (entity.Submission, error)
        GetSubmissionByID(ctx context.Context, id int) (entity.Submission, error)
        DeleteSubmission(ctx context.Context, id int) error
        GetAllSubmissions(ctx context.Context, page int, pageSize int, userID *uint) ([]entity.Submission, int64, error)         // Menambahkan parameter page dan pageSize
        GetAllSubmissionsWithUser(ctx context.Context, page int, pageSize int, userID *uint) ([]entity.Submission, int64, error) // Menambahkan parameter page dan pageSize
}

// submissionService adalah implementasi dari ISubmissionService yang menggunakan ISubmissionRepository
type submissionService struct {
        submissionRepo ISubmissionRepository
}

// NewsubmissionService membuat instance baru dari submissionService
func NewSubmissionService(submissionRepo ISubmissionRepository) ISubmissionService <span class="cov0" title="0">{
        return &amp;submissionService{submissionRepo: submissionRepo}
}</span>

// Create
func (s *submissionService) CreateSubmission(ctx context.Context, submission *entity.Submission) (entity.Submission, error) <span class="cov0" title="0">{
        // Memanggil CreateUser dari repository untuk membuat pengguna baru
        createdSubmission, err := s.submissionRepo.CreateSubmission(ctx, submission)
        if err != nil </span><span class="cov0" title="0">{
                return entity.Submission{}, fmt.Errorf("gagal membuat pengguna: %v", err)
        }</span>
        <span class="cov0" title="0">return createdSubmission, nil</span>
}

// GetUserByID mendapatkan pengguna berdasarkan ID
func (s *submissionService) GetSubmissionByID(ctx context.Context, id int) (entity.Submission, error) <span class="cov0" title="0">{
        // Memanggil GetUserByID dari repository untuk mendapatkan pengguna berdasarkan ID
        submission, err := s.submissionRepo.GetSubmissionByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return entity.Submission{}, fmt.Errorf("gagal mendapatkan submission berdasarkan ID: %v", err)
        }</span>
        <span class="cov0" title="0">return submission, nil</span>
}

// Delete submission
func (s *submissionService) DeleteSubmission(ctx context.Context, id int) error <span class="cov0" title="0">{
        // Memanggil DeleteUser dari repository untuk menghapus pengguna berdasarkan ID
        err := s.submissionRepo.DeleteSubmission(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gagal menghapus submission: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAllSubmission
func (s *submissionService) GetAllSubmissions(ctx context.Context, page int, pageSize int, userID *uint) ([]entity.Submission, int64, error) <span class="cov0" title="0">{
        // Memanggil GetAllUsers dari repository untuk mendapatkan semua pengguna
        Submissions, total, err := s.submissionRepo.GetAllSubmissions(ctx, page, pageSize, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("gagal mendapatkan semua submissions: %v", err)
        }</span>
        <span class="cov0" title="0">return Submissions, total, nil</span>
}

func (s *submissionService) GetAllSubmissionsWithUser(ctx context.Context, page int, pageSize int, userID *uint) ([]entity.Submission, int64, error) <span class="cov0" title="0">{
        // Memanggil GetAllUsers dari repository untuk mendapatkan semua pengguna
        Submissions, total, err := s.submissionRepo.GetAllSubmissionsWithUser(ctx, page, pageSize, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("gagal mendapatkan semua submissions: %v", err)
        }</span>
        <span class="cov0" title="0">return Submissions, total, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "assignment1/entity"
        "context"
        "fmt"
)

// IUserService mendefinisikan interface untuk layanan pengguna
type IUserService interface {
        CreateUser(ctx context.Context, user *entity.User) (entity.User, error)
        GetUserByID(ctx context.Context, id int) (entity.User, error)
        UpdateUser(ctx context.Context, id int, user entity.User) (entity.User, error)
        DeleteUser(ctx context.Context, id int) error
        GetAllUsers(ctx context.Context, page int, pageSize int) ([]entity.User, int64, error)         // Menambahkan parameter page dan pageSize
        GetAllUsersWithRisk(ctx context.Context, page int, pageSize int) ([]entity.User, int64, error) // Menambahkan parameter page dan pageSize
}

// IUserRepository mendefinisikan interface untuk repository pengguna
type IUserRepository interface {
        CreateUser(ctx context.Context, user *entity.User) (entity.User, error)
        GetUserByID(ctx context.Context, id int) (entity.User, error)
        UpdateUser(ctx context.Context, id int, user entity.User) (entity.User, error)
        DeleteUser(ctx context.Context, id int) error
        GetAllUsers(ctx context.Context, page int, pageSize int) ([]entity.User, int64, error)         // Menambahkan parameter page dan pageSize
        GetAllUsersWithRisk(ctx context.Context, page int, pageSize int) ([]entity.User, int64, error) // Menambahkan parameter page dan pageSize
}

// userService adalah implementasi dari IUserService yang menggunakan IUserRepository
type userService struct {
        userRepo IUserRepository
}

// NewUserService membuat instance baru dari userService
func NewUserService(userRepo IUserRepository) IUserService <span class="cov8" title="1">{
        return &amp;userService{userRepo: userRepo}
}</span>

// CreateUser membuat pengguna baru
func (s *userService) CreateUser(ctx context.Context, user *entity.User) (entity.User, error) <span class="cov8" title="1">{
        // Memanggil CreateUser dari repository untuk membuat pengguna baru
        createdUser, err := s.userRepo.CreateUser(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                return entity.User{}, fmt.Errorf("gagal membuat pengguna: %v", err)
        }</span>
        <span class="cov8" title="1">return createdUser, nil</span>
}

// GetUserByID mendapatkan pengguna berdasarkan ID
func (s *userService) GetUserByID(ctx context.Context, id int) (entity.User, error) <span class="cov0" title="0">{
        // Memanggil GetUserByID dari repository untuk mendapatkan pengguna berdasarkan ID
        user, err := s.userRepo.GetUserByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return entity.User{}, fmt.Errorf("gagal mendapatkan pengguna berdasarkan ID: %v", err)
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

// UpdateUser memperbarui data pengguna
func (s *userService) UpdateUser(ctx context.Context, id int, user entity.User) (entity.User, error) <span class="cov0" title="0">{
        // Memanggil UpdateUser dari repository untuk memperbarui data pengguna
        updatedUser, err := s.userRepo.UpdateUser(ctx, id, user)
        if err != nil </span><span class="cov0" title="0">{
                return entity.User{}, fmt.Errorf("gagal memperbarui pengguna: %v", err)
        }</span>
        <span class="cov0" title="0">return updatedUser, nil</span>
}

// DeleteUser menghapus pengguna berdasarkan ID
func (s *userService) DeleteUser(ctx context.Context, id int) error <span class="cov0" title="0">{
        // Memanggil DeleteUser dari repository untuk menghapus pengguna berdasarkan ID
        err := s.userRepo.DeleteUser(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gagal menghapus pengguna: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAllUsers mendapatkan semua pengguna
func (s *userService) GetAllUsers(ctx context.Context, page int, pageSize int) ([]entity.User, int64, error) <span class="cov0" title="0">{
        // Memanggil GetAllUsers dari repository untuk mendapatkan semua pengguna
        users, total, err := s.userRepo.GetAllUsers(ctx, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("gagal mendapatkan semua pengguna: %v", err)
        }</span>
        <span class="cov0" title="0">return users, total, nil</span>
}

func (s *userService) GetAllUsersWithRisk(ctx context.Context, page int, pageSize int) ([]entity.User, int64, error) <span class="cov0" title="0">{
        users, total, err := s.userRepo.GetAllUsersWithRisk(ctx, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("gagal mendapatkan semua pengguna: %v", err)
        }</span>
        <span class="cov0" title="0">return users, total, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: handler/submission_handler.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
        reflect "reflect"

        gin "github.com/gin-gonic/gin"
        gomock "github.com/golang/mock/gomock"
)

// MockISubmissionHandler is a mock of ISubmissionHandler interface.
type MockISubmissionHandler struct {
        ctrl     *gomock.Controller
        recorder *MockISubmissionHandlerMockRecorder
}

// MockISubmissionHandlerMockRecorder is the mock recorder for MockISubmissionHandler.
type MockISubmissionHandlerMockRecorder struct {
        mock *MockISubmissionHandler
}

// NewMockISubmissionHandler creates a new mock instance.
func NewMockISubmissionHandler(ctrl *gomock.Controller) *MockISubmissionHandler <span class="cov0" title="0">{
        mock := &amp;MockISubmissionHandler{ctrl: ctrl}
        mock.recorder = &amp;MockISubmissionHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockISubmissionHandler) EXPECT() *MockISubmissionHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateSubmission mocks base method.
func (m *MockISubmissionHandler) CreateSubmission(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "CreateSubmission", c)
}</span>

// CreateSubmission indicates an expected call of CreateSubmission.
func (mr *MockISubmissionHandlerMockRecorder) CreateSubmission(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSubmission", reflect.TypeOf((*MockISubmissionHandler)(nil).CreateSubmission), c)
}</span>

// DeleteSubmission mocks base method.
func (m *MockISubmissionHandler) DeleteSubmission(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "DeleteSubmission", c)
}</span>

// DeleteSubmission indicates an expected call of DeleteSubmission.
func (mr *MockISubmissionHandlerMockRecorder) DeleteSubmission(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSubmission", reflect.TypeOf((*MockISubmissionHandler)(nil).DeleteSubmission), c)
}</span>

// GetAllSubmissions mocks base method.
func (m *MockISubmissionHandler) GetAllSubmissions(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetAllSubmissions", c)
}</span>

// GetAllSubmissions indicates an expected call of GetAllSubmissions.
func (mr *MockISubmissionHandlerMockRecorder) GetAllSubmissions(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllSubmissions", reflect.TypeOf((*MockISubmissionHandler)(nil).GetAllSubmissions), c)
}</span>

// GetAllSubmissionsWithUser mocks base method.
func (m *MockISubmissionHandler) GetAllSubmissionsWithUser(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetAllSubmissionsWithUser", c)
}</span>

// GetAllSubmissionsWithUser indicates an expected call of GetAllSubmissionsWithUser.
func (mr *MockISubmissionHandlerMockRecorder) GetAllSubmissionsWithUser(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllSubmissionsWithUser", reflect.TypeOf((*MockISubmissionHandler)(nil).GetAllSubmissionsWithUser), c)
}</span>

// GetSubmission mocks base method.
func (m *MockISubmissionHandler) GetSubmission(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetSubmission", c)
}</span>

// GetSubmission indicates an expected call of GetSubmission.
func (mr *MockISubmissionHandlerMockRecorder) GetSubmission(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubmission", reflect.TypeOf((*MockISubmissionHandler)(nil).GetSubmission), c)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: handler/user_handler.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
        reflect "reflect"

        gin "github.com/gin-gonic/gin"
        gomock "github.com/golang/mock/gomock"
)

// MockIUserHandler is a mock of IUserHandler interface.
type MockIUserHandler struct {
        ctrl     *gomock.Controller
        recorder *MockIUserHandlerMockRecorder
}

// MockIUserHandlerMockRecorder is the mock recorder for MockIUserHandler.
type MockIUserHandlerMockRecorder struct {
        mock *MockIUserHandler
}

// NewMockIUserHandler creates a new mock instance.
func NewMockIUserHandler(ctrl *gomock.Controller) *MockIUserHandler <span class="cov0" title="0">{
        mock := &amp;MockIUserHandler{ctrl: ctrl}
        mock.recorder = &amp;MockIUserHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUserHandler) EXPECT() *MockIUserHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockIUserHandler) CreateUser(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "CreateUser", c)
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockIUserHandlerMockRecorder) CreateUser(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockIUserHandler)(nil).CreateUser), c)
}</span>

// DeleteUser mocks base method.
func (m *MockIUserHandler) DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "DeleteUser", c)
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockIUserHandlerMockRecorder) DeleteUser(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockIUserHandler)(nil).DeleteUser), c)
}</span>

// GetAllUsers mocks base method.
func (m *MockIUserHandler) GetAllUsers(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetAllUsers", c)
}</span>

// GetAllUsers indicates an expected call of GetAllUsers.
func (mr *MockIUserHandlerMockRecorder) GetAllUsers(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsers", reflect.TypeOf((*MockIUserHandler)(nil).GetAllUsers), c)
}</span>

// GetAllUsersWithRIsk mocks base method.
func (m *MockIUserHandler) GetAllUsersWithRIsk(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetAllUsersWithRIsk", c)
}</span>

// GetAllUsersWithRIsk indicates an expected call of GetAllUsersWithRIsk.
func (mr *MockIUserHandlerMockRecorder) GetAllUsersWithRIsk(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsersWithRIsk", reflect.TypeOf((*MockIUserHandler)(nil).GetAllUsersWithRIsk), c)
}</span>

// GetUser mocks base method.
func (m *MockIUserHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetUser", c)
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockIUserHandlerMockRecorder) GetUser(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockIUserHandler)(nil).GetUser), c)
}</span>

// UpdateUser mocks base method.
func (m *MockIUserHandler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "UpdateUser", c)
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockIUserHandlerMockRecorder) UpdateUser(c interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockIUserHandler)(nil).UpdateUser), c)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: service/user_service.go

// Package mock_service is a generated GoMock package.
package mock_service

import (
        entity "assignment1/entity"
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockIUserService is a mock of IUserService interface.
type MockIUserService struct {
        ctrl     *gomock.Controller
        recorder *MockIUserServiceMockRecorder
}

// MockIUserServiceMockRecorder is the mock recorder for MockIUserService.
type MockIUserServiceMockRecorder struct {
        mock *MockIUserService
}

// NewMockIUserService creates a new mock instance.
func NewMockIUserService(ctrl *gomock.Controller) *MockIUserService <span class="cov8" title="1">{
        mock := &amp;MockIUserService{ctrl: ctrl}
        mock.recorder = &amp;MockIUserServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUserService) EXPECT() *MockIUserServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockIUserService) CreateUser(ctx context.Context, user *entity.User) (entity.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, user)
        ret0, _ := ret[0].(entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockIUserServiceMockRecorder) CreateUser(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockIUserService)(nil).CreateUser), ctx, user)
}</span>

// DeleteUser mocks base method.
func (m *MockIUserService) DeleteUser(ctx context.Context, id int) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockIUserServiceMockRecorder) DeleteUser(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockIUserService)(nil).DeleteUser), ctx, id)
}</span>

// GetAllUsers mocks base method.
func (m *MockIUserService) GetAllUsers(ctx context.Context, page, pageSize int) ([]entity.User, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllUsers", ctx, page, pageSize)
        ret0, _ := ret[0].([]entity.User)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetAllUsers indicates an expected call of GetAllUsers.
func (mr *MockIUserServiceMockRecorder) GetAllUsers(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsers", reflect.TypeOf((*MockIUserService)(nil).GetAllUsers), ctx, page, pageSize)
}</span>

// GetAllUsersWithRisk mocks base method.
func (m *MockIUserService) GetAllUsersWithRisk(ctx context.Context, page, pageSize int) ([]entity.User, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllUsersWithRisk", ctx, page, pageSize)
        ret0, _ := ret[0].([]entity.User)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetAllUsersWithRisk indicates an expected call of GetAllUsersWithRisk.
func (mr *MockIUserServiceMockRecorder) GetAllUsersWithRisk(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsersWithRisk", reflect.TypeOf((*MockIUserService)(nil).GetAllUsersWithRisk), ctx, page, pageSize)
}</span>

// GetUserByID mocks base method.
func (m *MockIUserService) GetUserByID(ctx context.Context, id int) (entity.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, id)
        ret0, _ := ret[0].(entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockIUserServiceMockRecorder) GetUserByID(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockIUserService)(nil).GetUserByID), ctx, id)
}</span>

// UpdateUser mocks base method.
func (m *MockIUserService) UpdateUser(ctx context.Context, id int, user entity.User) (entity.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", ctx, id, user)
        ret0, _ := ret[0].(entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockIUserServiceMockRecorder) UpdateUser(ctx, id, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockIUserService)(nil).UpdateUser), ctx, id, user)
}</span>

// MockIUserRepository is a mock of IUserRepository interface.
type MockIUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockIUserRepositoryMockRecorder
}

// MockIUserRepositoryMockRecorder is the mock recorder for MockIUserRepository.
type MockIUserRepositoryMockRecorder struct {
        mock *MockIUserRepository
}

// NewMockIUserRepository creates a new mock instance.
func NewMockIUserRepository(ctrl *gomock.Controller) *MockIUserRepository <span class="cov8" title="1">{
        mock := &amp;MockIUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockIUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUserRepository) EXPECT() *MockIUserRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockIUserRepository) CreateUser(ctx context.Context, user *entity.User) (entity.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, user)
        ret0, _ := ret[0].(entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockIUserRepositoryMockRecorder) CreateUser(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockIUserRepository)(nil).CreateUser), ctx, user)
}</span>

// DeleteUser mocks base method.
func (m *MockIUserRepository) DeleteUser(ctx context.Context, id int) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockIUserRepositoryMockRecorder) DeleteUser(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockIUserRepository)(nil).DeleteUser), ctx, id)
}</span>

// GetAllUsers mocks base method.
func (m *MockIUserRepository) GetAllUsers(ctx context.Context, page, pageSize int) ([]entity.User, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllUsers", ctx, page, pageSize)
        ret0, _ := ret[0].([]entity.User)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetAllUsers indicates an expected call of GetAllUsers.
func (mr *MockIUserRepositoryMockRecorder) GetAllUsers(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsers", reflect.TypeOf((*MockIUserRepository)(nil).GetAllUsers), ctx, page, pageSize)
}</span>

// GetAllUsersWithRisk mocks base method.
func (m *MockIUserRepository) GetAllUsersWithRisk(ctx context.Context, page, pageSize int) ([]entity.User, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllUsersWithRisk", ctx, page, pageSize)
        ret0, _ := ret[0].([]entity.User)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetAllUsersWithRisk indicates an expected call of GetAllUsersWithRisk.
func (mr *MockIUserRepositoryMockRecorder) GetAllUsersWithRisk(ctx, page, pageSize interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsersWithRisk", reflect.TypeOf((*MockIUserRepository)(nil).GetAllUsersWithRisk), ctx, page, pageSize)
}</span>

// GetUserByID mocks base method.
func (m *MockIUserRepository) GetUserByID(ctx context.Context, id int) (entity.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, id)
        ret0, _ := ret[0].(entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockIUserRepositoryMockRecorder) GetUserByID(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockIUserRepository)(nil).GetUserByID), ctx, id)
}</span>

// UpdateUser mocks base method.
func (m *MockIUserRepository) UpdateUser(ctx context.Context, id int, user entity.User) (entity.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", ctx, id, user)
        ret0, _ := ret[0].(entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockIUserRepositoryMockRecorder) UpdateUser(ctx, id, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockIUserRepository)(nil).UpdateUser), ctx, id, user)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
